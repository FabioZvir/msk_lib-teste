// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'model.dart';

// **************************************************************************
// SqfEntityGenerator
// **************************************************************************

// ignore_for_file: non_constant_identifier_names

//  These classes was generated by SqfEntity
//  Copyright (c) 2019, All rights reserved. Use of this source code is governed by a
//  Apache license that can be found in the LICENSE file.

//  To use these SqfEntity classes do following:
//  - import model.dart into where to use
//  - start typing ex:RegistroAtividade.select()... (add a few filters with fluent methods)...(add orderBy/orderBydesc if you want)...
//  - and then just put end of filters / or end of only select()  toSingle() / or toList()
//  - you can select one or return List<yourObject> by your filters and orders
//  - also you can batch update or batch delete by using delete/update methods instead of tosingle/tolist methods
//    Enjoy.. Huseyin Tokpunar

// BEGIN TABLES
// RegistroAtividade TABLE
class TableRegistroAtividade extends SqfEntityTableBase {
  TableRegistroAtividade() {
    // declare properties of EntityTable
    tableName = 'RegistroAtividade';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = true;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('idServer', DbType.integer, defaultValue: -1),
      SqfEntityFieldBase('sync', DbType.bool, defaultValue: true),
      SqfEntityFieldBase('tabela', DbType.text),
      SqfEntityFieldBase('log', DbType.text),
      SqfEntityFieldBase('tipo', DbType.integer),
      SqfEntityFieldBase('data', DbType.datetime,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('codUsu', DbType.integer),
      SqfEntityFieldBase('codUsuTimber', DbType.integer),
      SqfEntityFieldBase('app', DbType.text),
      SqfEntityFieldBase('idDevice', DbType.text),
      SqfEntityFieldBase('versao', DbType.integer),
      SqfEntityFieldBase('lastUpdate', DbType.integer),
      SqfEntityFieldBase('uniqueKey', DbType.integer),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableRegistroAtividade();
  }
}

// ArquivoRegistroAtividade TABLE
class TableArquivoRegistroAtividade extends SqfEntityTableBase {
  TableArquivoRegistroAtividade() {
    // declare properties of EntityTable
    tableName = 'ArquivoRegistroAtividade';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = true;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('idServer', DbType.integer, defaultValue: -1),
      SqfEntityFieldBase('sync', DbType.bool, defaultValue: true),
      SqfEntityFieldBase('path', DbType.text),
      SqfEntityFieldBase('codUsuTimber', DbType.integer),
      SqfEntityFieldRelationshipBase(
          TableRegistroAtividade.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'registroAtividade_id',
          defaultValue: 0),
      SqfEntityFieldBase('lastUpdate', DbType.integer),
      SqfEntityFieldBase('uniqueKey', DbType.integer),
      SqfEntityFieldBase('codUsu', DbType.integer, defaultValue: -2),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableArquivoRegistroAtividade();
  }
}

// FeedbackUsuario TABLE
class TableFeedbackUsuario extends SqfEntityTableBase {
  TableFeedbackUsuario() {
    // declare properties of EntityTable
    tableName = 'FeedbackUsuario';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = true;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('idServer', DbType.integer, defaultValue: -1),
      SqfEntityFieldBase('sync', DbType.bool, defaultValue: true),
      SqfEntityFieldBase('avaliacao', DbType.integer),
      SqfEntityFieldBase('texto', DbType.text),
      SqfEntityFieldBase('package', DbType.text),
      SqfEntityFieldBase('codUsuTimber', DbType.integer),
      SqfEntityFieldBase('tipoFeedback', DbType.integer),
      SqfEntityFieldBase('lastUpdate', DbType.integer),
      SqfEntityFieldBase('uniqueKey', DbType.integer),
      SqfEntityFieldBase('codUsu', DbType.integer, defaultValue: -2),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableFeedbackUsuario();
  }
}

// ArquivoFeedback TABLE
class TableArquivoFeedback extends SqfEntityTableBase {
  TableArquivoFeedback() {
    // declare properties of EntityTable
    tableName = 'ArquivoFeedback';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = true;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('idServer', DbType.integer, defaultValue: -1),
      SqfEntityFieldBase('sync', DbType.bool, defaultValue: true),
      SqfEntityFieldBase('url', DbType.text),
      SqfEntityFieldBase('path', DbType.text),
      SqfEntityFieldBase('codUsuTimber', DbType.integer),
      SqfEntityFieldRelationshipBase(
          TableFeedbackUsuario.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'feedbackUsuario_id',
          defaultValue: 0),
      SqfEntityFieldBase('lastUpdate', DbType.integer),
      SqfEntityFieldBase('uniqueKey', DbType.integer),
      SqfEntityFieldBase('codUsu', DbType.integer, defaultValue: -2),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableArquivoFeedback();
  }
}
// END TABLES

// BEGIN SEQUENCES
// identity SEQUENCE
class SequenceIdentitySequence extends SqfEntitySequenceBase {
  SequenceIdentitySequence() {
    sequenceName = 'identity';
    maxValue =
        9007199254740991; /* optional. default is max int (9.223.372.036.854.775.807) */
    cycle = false; /* optional. default is false; */
    minValue = 0; /* optional. default is 0 */
    incrementBy = 1; /* optional. default is 1 */
    startWith = 0; /* optional. default is 0 */
    super.init();
  }
  static SequenceIdentitySequence? _instance;
  static SequenceIdentitySequence get getInstance {
    return _instance = _instance ?? SequenceIdentitySequence();
  }
}
// END SEQUENCES

// BEGIN DATABASE MODEL
class AppDatabase extends SqfEntityModelProvider {
  AppDatabase() {
    databaseName = myDbModel.databaseName;
    password = myDbModel.password;
    dbVersion = myDbModel.dbVersion;
    preSaveAction = myDbModel.preSaveAction;
    logFunction = myDbModel.logFunction;
    databaseTables = [
      TableRegistroAtividade.getInstance,
      TableArquivoRegistroAtividade.getInstance,
      TableFeedbackUsuario.getInstance,
      TableArquivoFeedback.getInstance,
    ];

    sequences = [
      SequenceIdentitySequence.getInstance,
    ];

    bundledDatabasePath = myDbModel
        .bundledDatabasePath; //'assets/sample.db'; // This value is optional. When bundledDatabasePath is empty then EntityBase creats a new database when initializing the database
    databasePath = myDbModel.databasePath;
  }
  Map<String, dynamic> getControllers() {
    final controllers = <String, dynamic>{};

    return controllers;
  }
}
// END DATABASE MODEL

// BEGIN ENTITIES
// region RegistroAtividade
class RegistroAtividade extends TableBase {
  RegistroAtividade(
      {this.id,
      this.idServer,
      this.sync,
      this.tabela,
      this.log,
      this.tipo,
      this.data,
      this.codUsu,
      this.codUsuTimber,
      this.app,
      this.idDevice,
      this.versao,
      this.lastUpdate,
      this.uniqueKey,
      this.isDeleted}) {
    _setDefaultValues();
    softDeleteActivated = true;
  }
  RegistroAtividade.withFields(
      this.idServer,
      this.sync,
      this.tabela,
      this.log,
      this.tipo,
      this.data,
      this.codUsu,
      this.codUsuTimber,
      this.app,
      this.idDevice,
      this.versao,
      this.lastUpdate,
      this.uniqueKey,
      this.isDeleted) {
    _setDefaultValues();
  }
  RegistroAtividade.withId(
      this.id,
      this.idServer,
      this.sync,
      this.tabela,
      this.log,
      this.tipo,
      this.data,
      this.codUsu,
      this.codUsuTimber,
      this.app,
      this.idDevice,
      this.versao,
      this.lastUpdate,
      this.uniqueKey,
      this.isDeleted) {
    _setDefaultValues();
  }
  // fromMap v2.0
  RegistroAtividade.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['idServer'] != null) {
      idServer = int.tryParse(o['idServer'].toString());
    }
    if (o['sync'] != null) {
      sync = o['sync'].toString() == '1' || o['sync'].toString() == 'true';
    }
    if (o['tabela'] != null) {
      tabela = o['tabela'].toString();
    }
    if (o['log'] != null) {
      log = o['log'].toString();
    }
    if (o['tipo'] != null) {
      tipo = int.tryParse(o['tipo'].toString());
    }
    if (o['data'] != null) {
      data = int.tryParse(o['data'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['data'].toString())!)
          : DateTime.tryParse(o['data'].toString());
    }
    if (o['codUsu'] != null) {
      codUsu = int.tryParse(o['codUsu'].toString());
    }
    if (o['codUsuTimber'] != null) {
      codUsuTimber = int.tryParse(o['codUsuTimber'].toString());
    }
    if (o['app'] != null) {
      app = o['app'].toString();
    }
    if (o['idDevice'] != null) {
      idDevice = o['idDevice'].toString();
    }
    if (o['versao'] != null) {
      versao = int.tryParse(o['versao'].toString());
    }
    if (o['lastUpdate'] != null) {
      lastUpdate = int.tryParse(o['lastUpdate'].toString());
    }
    if (o['uniqueKey'] != null) {
      uniqueKey = int.tryParse(o['uniqueKey'].toString());
    }
    isDeleted = o['isDeleted'] != null
        ? o['isDeleted'] == 1 || o['isDeleted'] == true
        : null;
  }
  // FIELDS (RegistroAtividade)
  int? id;
  int? idServer;
  bool? sync;
  String? tabela;
  String? log;
  int? tipo;
  DateTime? data;
  int? codUsu;
  int? codUsuTimber;
  String? app;
  String? idDevice;
  int? versao;
  int? lastUpdate;
  int? uniqueKey;
  bool? isDeleted;

  // end FIELDS (RegistroAtividade)

// COLLECTIONS & VIRTUALS (RegistroAtividade)
  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plArquivoRegistroAtividades', 'plField2'..]) or so on..
  List<ArquivoRegistroAtividade>? plArquivoRegistroAtividades;

  /// get ArquivoRegistroAtividade(s) filtered by id=registroAtividade_id
  ArquivoRegistroAtividadeFilterBuilder? getArquivoRegistroAtividades(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    if (id == null) {
      return null;
    }
    return ArquivoRegistroAtividade()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .registroAtividade_id
        .equals(id)
        .and;
  }

// END COLLECTIONS & VIRTUALS (RegistroAtividade)

  static const bool _softDeleteActivated = true;
  RegistroAtividadeManager? __mnRegistroAtividade;

  RegistroAtividadeManager get _mnRegistroAtividade {
    return __mnRegistroAtividade =
        __mnRegistroAtividade ?? RegistroAtividadeManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (idServer != null || !forView) {
      map['idServer'] = idServer;
    }
    if (sync != null) {
      map['sync'] = forQuery ? (sync! ? 1 : 0) : sync;
    } else if (sync != null || !forView) {
      map['sync'] = null;
    }
    if (tabela != null || !forView) {
      map['tabela'] = tabela;
    }
    if (log != null || !forView) {
      map['log'] = log;
    }
    if (tipo != null || !forView) {
      map['tipo'] = tipo;
    }
    if (data != null) {
      map['data'] = forJson
          ? data!.toString()
          : forQuery
              ? data!.millisecondsSinceEpoch
              : data;
    } else if (data != null || !forView) {
      map['data'] = null;
    }
    if (codUsu != null || !forView) {
      map['codUsu'] = codUsu;
    }
    if (codUsuTimber != null || !forView) {
      map['codUsuTimber'] = codUsuTimber;
    }
    if (app != null || !forView) {
      map['app'] = app;
    }
    if (idDevice != null || !forView) {
      map['idDevice'] = idDevice;
    }
    if (versao != null || !forView) {
      map['versao'] = versao;
    }
    if (lastUpdate != null || !forView) {
      map['lastUpdate'] = lastUpdate;
    }
    if (uniqueKey != null || !forView) {
      map['uniqueKey'] = uniqueKey;
    }
    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted! ? 1 : 0) : isDeleted;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (idServer != null || !forView) {
      map['idServer'] = idServer;
    }
    if (sync != null) {
      map['sync'] = forQuery ? (sync! ? 1 : 0) : sync;
    } else if (sync != null || !forView) {
      map['sync'] = null;
    }
    if (tabela != null || !forView) {
      map['tabela'] = tabela;
    }
    if (log != null || !forView) {
      map['log'] = log;
    }
    if (tipo != null || !forView) {
      map['tipo'] = tipo;
    }
    if (data != null) {
      map['data'] = forJson
          ? data!.toString()
          : forQuery
              ? data!.millisecondsSinceEpoch
              : data;
    } else if (data != null || !forView) {
      map['data'] = null;
    }
    if (codUsu != null || !forView) {
      map['codUsu'] = codUsu;
    }
    if (codUsuTimber != null || !forView) {
      map['codUsuTimber'] = codUsuTimber;
    }
    if (app != null || !forView) {
      map['app'] = app;
    }
    if (idDevice != null || !forView) {
      map['idDevice'] = idDevice;
    }
    if (versao != null || !forView) {
      map['versao'] = versao;
    }
    if (lastUpdate != null || !forView) {
      map['lastUpdate'] = lastUpdate;
    }
    if (uniqueKey != null || !forView) {
      map['uniqueKey'] = uniqueKey;
    }
    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted! ? 1 : 0) : isDeleted;
    }

// COLLECTIONS (RegistroAtividade)
    if (!forQuery) {
      map['ArquivoRegistroAtividades'] =
          await getArquivoRegistroAtividades()!.toMapList();
    }
// END COLLECTIONS (RegistroAtividade)

    return map;
  }

  /// This method returns Json String [RegistroAtividade]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [RegistroAtividade]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      idServer,
      sync,
      tabela,
      log,
      tipo,
      data != null ? data!.millisecondsSinceEpoch : null,
      codUsu,
      codUsuTimber,
      app,
      idDevice,
      versao,
      lastUpdate,
      uniqueKey,
      isDeleted
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      id,
      idServer,
      sync,
      tabela,
      log,
      tipo,
      data != null ? data!.millisecondsSinceEpoch : null,
      codUsu,
      codUsuTimber,
      app,
      idDevice,
      versao,
      lastUpdate,
      uniqueKey,
      isDeleted
    ];
  }

  static Future<List<RegistroAtividade>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR RegistroAtividade.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<RegistroAtividade>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <RegistroAtividade>[];
    try {
      objList = list
          .map((registroatividade) => RegistroAtividade.fromMap(
              registroatividade as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR RegistroAtividade.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<RegistroAtividade>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<RegistroAtividade> objList = <RegistroAtividade>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = RegistroAtividade.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('RegistroAtividade.plArquivoRegistroAtividades') && */ (preloadFields ==
                null ||
            preloadFields.contains('plArquivoRegistroAtividades'))) {
          /*_loadedfields!.add('RegistroAtividade.plArquivoRegistroAtividades'); */ obj
                  .plArquivoRegistroAtividades =
              obj.plArquivoRegistroAtividades ??
                  await obj.getArquivoRegistroAtividades()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      objList.add(obj);
    }
    return objList;
  }

  /// returns RegistroAtividade by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [RegistroAtividade] if exist, otherwise returns null
  Future<RegistroAtividade?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    RegistroAtividade? obj;
    final data = await _mnRegistroAtividade.getById([id]);
    if (data.length != 0) {
      obj = RegistroAtividade.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('RegistroAtividade.plArquivoRegistroAtividades') && */ (preloadFields ==
                null ||
            preloadFields.contains('plArquivoRegistroAtividades'))) {
          /*_loadedfields!.add('RegistroAtividade.plArquivoRegistroAtividades'); */ obj
                  .plArquivoRegistroAtividades =
              obj.plArquivoRegistroAtividades ??
                  await obj.getArquivoRegistroAtividades()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (RegistroAtividade) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnRegistroAtividade.insert(this, ignoreBatch);
    } else {
      await _mnRegistroAtividade.update(this);
    }

    return id;
  }

  /// Saves the (RegistroAtividade) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnRegistroAtividade.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnRegistroAtividade.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs RegistroAtividade. Returns a new Primary Key value of RegistroAtividade

  /// <returns>Returns a new Primary Key value of RegistroAtividade
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    id = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<RegistroAtividade> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<RegistroAtividade> registroatividades,
      {bool? exclusive,
      bool? noResult,
      bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await AppDatabase().batchStart();
    for (final obj in registroatividades) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await AppDatabase().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < registroatividades.length; i++) {
        if (registroatividades[i].id == null) {
          registroatividades[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnRegistroAtividade.rawInsert(
          'INSERT OR REPLACE INTO RegistroAtividade (id, idServer, sync, tabela, log, tipo, data, codUsu, codUsuTimber, app, idDevice, versao, lastUpdate, uniqueKey,isDeleted)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            id,
            idServer,
            sync,
            tabela,
            log,
            tipo,
            data != null ? data!.millisecondsSinceEpoch : null,
            codUsu,
            codUsuTimber,
            app,
            idDevice,
            versao,
            lastUpdate,
            uniqueKey,
            isDeleted
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'RegistroAtividade id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'RegistroAtividade id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'RegistroAtividade Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<RegistroAtividade>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<RegistroAtividade> registroatividades,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnRegistroAtividade.rawInsertAll(
        'INSERT OR REPLACE INTO RegistroAtividade (id, idServer, sync, tabela, log, tipo, data, codUsu, codUsuTimber, app, idDevice, versao, lastUpdate, uniqueKey,isDeleted)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
        registroatividades,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes RegistroAtividade

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete RegistroAtividade invoked (id=$id)');
    var result = BoolResult(success: false);
    {
      result = await ArquivoRegistroAtividade()
          .select()
          .registroAtividade_id
          .equals(id)
          .and
          .delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    if (!_softDeleteActivated || hardDelete || isDeleted!) {
      return _mnRegistroAtividade
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnRegistroAtividade.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  /// Recover RegistroAtividade

  /// <returns>BoolResult res.success=Recovered, not res.success=Can not recovered
  @override
  Future<BoolResult> recover([bool recoverChilds = true]) async {
    debugPrint('SQFENTITIY: recover RegistroAtividade invoked (id=$id)');
    var result = BoolResult(success: false);
    if (recoverChilds) {
      result = await ArquivoRegistroAtividade()
          .select(getIsDeleted: true)
          .isDeleted
          .equals(true)
          .and
          .registroAtividade_id
          .equals(id)
          .and
          .update({'isDeleted': 0});
    }
    if (!result.success && recoverChilds) {
      return result;
    }
    {
      return _mnRegistroAtividade.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 0});
    }
  }

  @override
  RegistroAtividadeFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return RegistroAtividadeFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  RegistroAtividadeFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return RegistroAtividadeFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    idServer = idServer ?? -1;
    sync = sync ?? true;
    isDeleted = isDeleted ?? false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion registroatividade

// region RegistroAtividadeField
class RegistroAtividadeField extends FilterBase {
  RegistroAtividadeField(RegistroAtividadeFilterBuilder registroatividadeFB)
      : super(registroatividadeFB);

  @override
  RegistroAtividadeFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as RegistroAtividadeFilterBuilder;
  }

  @override
  RegistroAtividadeFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as RegistroAtividadeFilterBuilder;
  }

  @override
  RegistroAtividadeFilterBuilder isNull() {
    return super.isNull() as RegistroAtividadeFilterBuilder;
  }

  @override
  RegistroAtividadeFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as RegistroAtividadeFilterBuilder;
  }

  @override
  RegistroAtividadeFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as RegistroAtividadeFilterBuilder;
  }

  @override
  RegistroAtividadeFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as RegistroAtividadeFilterBuilder;
  }

  @override
  RegistroAtividadeFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as RegistroAtividadeFilterBuilder;
  }

  @override
  RegistroAtividadeFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as RegistroAtividadeFilterBuilder;
  }

  @override
  RegistroAtividadeFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as RegistroAtividadeFilterBuilder;
  }

  @override
  RegistroAtividadeFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as RegistroAtividadeFilterBuilder;
  }

  @override
  RegistroAtividadeFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as RegistroAtividadeFilterBuilder;
  }

  @override
  RegistroAtividadeFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as RegistroAtividadeFilterBuilder;
  }

  @override
  RegistroAtividadeField get not {
    return super.not as RegistroAtividadeField;
  }
}
// endregion RegistroAtividadeField

// region RegistroAtividadeFilterBuilder
class RegistroAtividadeFilterBuilder extends ConjunctionBase {
  RegistroAtividadeFilterBuilder(RegistroAtividade obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnRegistroAtividade = obj._mnRegistroAtividade;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  RegistroAtividadeManager? _mnRegistroAtividade;

  /// put the sql keyword 'AND'
  @override
  RegistroAtividadeFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  RegistroAtividadeFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  RegistroAtividadeFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  RegistroAtividadeFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  RegistroAtividadeFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  RegistroAtividadeFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  RegistroAtividadeFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  RegistroAtividadeFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  RegistroAtividadeFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  RegistroAtividadeFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  RegistroAtividadeFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  RegistroAtividadeField _setField(
      RegistroAtividadeField? field, String colName, DbType dbtype) {
    return RegistroAtividadeField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  RegistroAtividadeField? _id;
  RegistroAtividadeField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  RegistroAtividadeField? _idServer;
  RegistroAtividadeField get idServer {
    return _idServer = _setField(_idServer, 'idServer', DbType.integer);
  }

  RegistroAtividadeField? _sync;
  RegistroAtividadeField get sync {
    return _sync = _setField(_sync, 'sync', DbType.bool);
  }

  RegistroAtividadeField? _tabela;
  RegistroAtividadeField get tabela {
    return _tabela = _setField(_tabela, 'tabela', DbType.text);
  }

  RegistroAtividadeField? _log;
  RegistroAtividadeField get log {
    return _log = _setField(_log, 'log', DbType.text);
  }

  RegistroAtividadeField? _tipo;
  RegistroAtividadeField get tipo {
    return _tipo = _setField(_tipo, 'tipo', DbType.integer);
  }

  RegistroAtividadeField? _data;
  RegistroAtividadeField get data {
    return _data = _setField(_data, 'data', DbType.datetime);
  }

  RegistroAtividadeField? _codUsu;
  RegistroAtividadeField get codUsu {
    return _codUsu = _setField(_codUsu, 'codUsu', DbType.integer);
  }

  RegistroAtividadeField? _codUsuTimber;
  RegistroAtividadeField get codUsuTimber {
    return _codUsuTimber =
        _setField(_codUsuTimber, 'codUsuTimber', DbType.integer);
  }

  RegistroAtividadeField? _app;
  RegistroAtividadeField get app {
    return _app = _setField(_app, 'app', DbType.text);
  }

  RegistroAtividadeField? _idDevice;
  RegistroAtividadeField get idDevice {
    return _idDevice = _setField(_idDevice, 'idDevice', DbType.text);
  }

  RegistroAtividadeField? _versao;
  RegistroAtividadeField get versao {
    return _versao = _setField(_versao, 'versao', DbType.integer);
  }

  RegistroAtividadeField? _lastUpdate;
  RegistroAtividadeField get lastUpdate {
    return _lastUpdate = _setField(_lastUpdate, 'lastUpdate', DbType.integer);
  }

  RegistroAtividadeField? _uniqueKey;
  RegistroAtividadeField get uniqueKey {
    return _uniqueKey = _setField(_uniqueKey, 'uniqueKey', DbType.integer);
  }

  RegistroAtividadeField? _isDeleted;
  RegistroAtividadeField get isDeleted {
    return _isDeleted = _setField(_isDeleted, 'isDeleted', DbType.bool);
  }

  /// Deletes List<RegistroAtividade> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);
    // Delete sub records where in (ArquivoRegistroAtividade) according to DeleteRule.CASCADE
    final idListArquivoRegistroAtividadeBYregistroAtividade_id =
        toListPrimaryKeySQL(false);
    final resArquivoRegistroAtividadeBYregistroAtividade_id =
        await ArquivoRegistroAtividade()
            .select()
            .where(
                'registroAtividade_id IN (${idListArquivoRegistroAtividadeBYregistroAtividade_id['sql']})',
                parameterValue:
                    idListArquivoRegistroAtividadeBYregistroAtividade_id[
                        'args'])
            .delete(hardDelete);
    if (!resArquivoRegistroAtividadeBYregistroAtividade_id.success) {
      return resArquivoRegistroAtividadeBYregistroAtividade_id;
    }

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnRegistroAtividade!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnRegistroAtividade!.delete(qparams);
    }
    return r;
  }

  /// Recover List<RegistroAtividade> bulk by query
  @override
  Future<BoolResult> recover() async {
    buildParameters(getIsDeleted: true);
    debugPrint('SQFENTITIY: recover RegistroAtividade bulk invoked');
    // Recover sub records where in (ArquivoRegistroAtividade) according to DeleteRule.CASCADE
    final idListArquivoRegistroAtividadeBYregistroAtividade_id =
        toListPrimaryKeySQL(false);
    final resArquivoRegistroAtividadeBYregistroAtividade_id =
        await ArquivoRegistroAtividade()
            .select()
            .where(
                'registroAtividade_id IN (${idListArquivoRegistroAtividadeBYregistroAtividade_id['sql']})',
                parameterValue:
                    idListArquivoRegistroAtividadeBYregistroAtividade_id[
                        'args'])
            .update({'isDeleted': 0});
    if (!resArquivoRegistroAtividadeBYregistroAtividade_id.success) {
      return resArquivoRegistroAtividadeBYregistroAtividade_id;
    }
    return _mnRegistroAtividade!.updateBatch(qparams, {'isDeleted': 0});
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from RegistroAtividade ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnRegistroAtividade!.updateBatch(qparams, values);
  }

  /// This method always returns [RegistroAtividade] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> RegistroAtividade?
  @override
  Future<RegistroAtividade?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnRegistroAtividade!.toList(qparams);
    final data = await objFuture;
    RegistroAtividade? obj;
    if (data.isNotEmpty) {
      obj = RegistroAtividade.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('RegistroAtividade.plArquivoRegistroAtividades') && */ (preloadFields ==
                null ||
            preloadFields.contains('plArquivoRegistroAtividades'))) {
          /*_loadedfields!.add('RegistroAtividade.plArquivoRegistroAtividades'); */ obj
                  .plArquivoRegistroAtividades =
              obj.plArquivoRegistroAtividades ??
                  await obj.getArquivoRegistroAtividades()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [RegistroAtividade]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> RegistroAtividade?
  @override
  Future<RegistroAtividade> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        RegistroAtividade();
  }

  /// This method returns int. [RegistroAtividade]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? registroatividadeCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final registroatividadesFuture =
        await _mnRegistroAtividade!.toList(qparams);
    final int count = registroatividadesFuture[0]['CNT'] as int;
    if (registroatividadeCount != null) {
      registroatividadeCount(count);
    }
    return count;
  }

  /// This method returns List<RegistroAtividade> [RegistroAtividade]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<RegistroAtividade>
  @override
  Future<List<RegistroAtividade>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<RegistroAtividade> registroatividadesData =
        await RegistroAtividade.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return registroatividadesData;
  }

  /// This method returns Json String [RegistroAtividade]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [RegistroAtividade]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [RegistroAtividade]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnRegistroAtividade!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [RegistroAtividade]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `id` FROM RegistroAtividade WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnRegistroAtividade!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [RegistroAtividade]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnRegistroAtividade!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await RegistroAtividade.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnRegistroAtividade!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion RegistroAtividadeFilterBuilder

// region RegistroAtividadeFields
class RegistroAtividadeFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fIdServer;
  static TableField get idServer {
    return _fIdServer = _fIdServer ??
        SqlSyntax.setField(_fIdServer, 'idServer', DbType.integer);
  }

  static TableField? _fSync;
  static TableField get sync {
    return _fSync = _fSync ?? SqlSyntax.setField(_fSync, 'sync', DbType.bool);
  }

  static TableField? _fTabela;
  static TableField get tabela {
    return _fTabela =
        _fTabela ?? SqlSyntax.setField(_fTabela, 'tabela', DbType.text);
  }

  static TableField? _fLog;
  static TableField get log {
    return _fLog = _fLog ?? SqlSyntax.setField(_fLog, 'log', DbType.text);
  }

  static TableField? _fTipo;
  static TableField get tipo {
    return _fTipo =
        _fTipo ?? SqlSyntax.setField(_fTipo, 'tipo', DbType.integer);
  }

  static TableField? _fData;
  static TableField get data {
    return _fData =
        _fData ?? SqlSyntax.setField(_fData, 'data', DbType.datetime);
  }

  static TableField? _fCodUsu;
  static TableField get codUsu {
    return _fCodUsu =
        _fCodUsu ?? SqlSyntax.setField(_fCodUsu, 'codUsu', DbType.integer);
  }

  static TableField? _fCodUsuTimber;
  static TableField get codUsuTimber {
    return _fCodUsuTimber = _fCodUsuTimber ??
        SqlSyntax.setField(_fCodUsuTimber, 'codUsuTimber', DbType.integer);
  }

  static TableField? _fApp;
  static TableField get app {
    return _fApp = _fApp ?? SqlSyntax.setField(_fApp, 'app', DbType.text);
  }

  static TableField? _fIdDevice;
  static TableField get idDevice {
    return _fIdDevice =
        _fIdDevice ?? SqlSyntax.setField(_fIdDevice, 'idDevice', DbType.text);
  }

  static TableField? _fVersao;
  static TableField get versao {
    return _fVersao =
        _fVersao ?? SqlSyntax.setField(_fVersao, 'versao', DbType.integer);
  }

  static TableField? _fLastUpdate;
  static TableField get lastUpdate {
    return _fLastUpdate = _fLastUpdate ??
        SqlSyntax.setField(_fLastUpdate, 'lastUpdate', DbType.integer);
  }

  static TableField? _fUniqueKey;
  static TableField get uniqueKey {
    return _fUniqueKey = _fUniqueKey ??
        SqlSyntax.setField(_fUniqueKey, 'uniqueKey', DbType.integer);
  }

  static TableField? _fIsDeleted;
  static TableField get isDeleted {
    return _fIsDeleted = _fIsDeleted ??
        SqlSyntax.setField(_fIsDeleted, 'isDeleted', DbType.integer);
  }
}
// endregion RegistroAtividadeFields

//region RegistroAtividadeManager
class RegistroAtividadeManager extends SqfEntityProvider {
  RegistroAtividadeManager()
      : super(AppDatabase(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'RegistroAtividade';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion RegistroAtividadeManager
// region ArquivoRegistroAtividade
class ArquivoRegistroAtividade extends TableBase {
  ArquivoRegistroAtividade(
      {this.id,
      this.idServer,
      this.sync,
      this.path,
      this.codUsuTimber,
      this.registroAtividade_id,
      this.lastUpdate,
      this.uniqueKey,
      this.codUsu,
      this.isDeleted}) {
    _setDefaultValues();
    softDeleteActivated = true;
  }
  ArquivoRegistroAtividade.withFields(
      this.idServer,
      this.sync,
      this.path,
      this.codUsuTimber,
      this.registroAtividade_id,
      this.lastUpdate,
      this.uniqueKey,
      this.codUsu,
      this.isDeleted) {
    _setDefaultValues();
  }
  ArquivoRegistroAtividade.withId(
      this.id,
      this.idServer,
      this.sync,
      this.path,
      this.codUsuTimber,
      this.registroAtividade_id,
      this.lastUpdate,
      this.uniqueKey,
      this.codUsu,
      this.isDeleted) {
    _setDefaultValues();
  }
  // fromMap v2.0
  ArquivoRegistroAtividade.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['idServer'] != null) {
      idServer = int.tryParse(o['idServer'].toString());
    }
    if (o['sync'] != null) {
      sync = o['sync'].toString() == '1' || o['sync'].toString() == 'true';
    }
    if (o['path'] != null) {
      path = o['path'].toString();
    }
    if (o['codUsuTimber'] != null) {
      codUsuTimber = int.tryParse(o['codUsuTimber'].toString());
    }
    registroAtividade_id = int.tryParse(o['registroAtividade_id'].toString());

    if (o['lastUpdate'] != null) {
      lastUpdate = int.tryParse(o['lastUpdate'].toString());
    }
    if (o['uniqueKey'] != null) {
      uniqueKey = int.tryParse(o['uniqueKey'].toString());
    }
    if (o['codUsu'] != null) {
      codUsu = int.tryParse(o['codUsu'].toString());
    }
    isDeleted = o['isDeleted'] != null
        ? o['isDeleted'] == 1 || o['isDeleted'] == true
        : null;

    // RELATIONSHIPS FromMAP
    plRegistroAtividade = o['registroAtividade'] != null
        ? RegistroAtividade.fromMap(
            o['registroAtividade'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP
  }
  // FIELDS (ArquivoRegistroAtividade)
  int? id;
  int? idServer;
  bool? sync;
  String? path;
  int? codUsuTimber;
  int? registroAtividade_id;
  int? lastUpdate;
  int? uniqueKey;
  int? codUsu;
  bool? isDeleted;

  // end FIELDS (ArquivoRegistroAtividade)

// RELATIONSHIPS (ArquivoRegistroAtividade)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plRegistroAtividade', 'plField2'..]) or so on..
  RegistroAtividade? plRegistroAtividade;

  /// get RegistroAtividade By RegistroAtividade_id
  Future<RegistroAtividade?> getRegistroAtividade(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await RegistroAtividade().getById(registroAtividade_id,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (ArquivoRegistroAtividade)

  static const bool _softDeleteActivated = true;
  ArquivoRegistroAtividadeManager? __mnArquivoRegistroAtividade;

  ArquivoRegistroAtividadeManager get _mnArquivoRegistroAtividade {
    return __mnArquivoRegistroAtividade =
        __mnArquivoRegistroAtividade ?? ArquivoRegistroAtividadeManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (idServer != null || !forView) {
      map['idServer'] = idServer;
    }
    if (sync != null) {
      map['sync'] = forQuery ? (sync! ? 1 : 0) : sync;
    } else if (sync != null || !forView) {
      map['sync'] = null;
    }
    if (path != null || !forView) {
      map['path'] = path;
    }
    if (codUsuTimber != null || !forView) {
      map['codUsuTimber'] = codUsuTimber;
    }
    if (registroAtividade_id != null) {
      map['registroAtividade_id'] = forView
          ? plRegistroAtividade == null
              ? registroAtividade_id
              : plRegistroAtividade!.tabela
          : registroAtividade_id;
    } else if (registroAtividade_id != null || !forView) {
      map['registroAtividade_id'] = null;
    }
    if (lastUpdate != null || !forView) {
      map['lastUpdate'] = lastUpdate;
    }
    if (uniqueKey != null || !forView) {
      map['uniqueKey'] = uniqueKey;
    }
    if (codUsu != null || !forView) {
      map['codUsu'] = codUsu;
    }
    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted! ? 1 : 0) : isDeleted;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (idServer != null || !forView) {
      map['idServer'] = idServer;
    }
    if (sync != null) {
      map['sync'] = forQuery ? (sync! ? 1 : 0) : sync;
    } else if (sync != null || !forView) {
      map['sync'] = null;
    }
    if (path != null || !forView) {
      map['path'] = path;
    }
    if (codUsuTimber != null || !forView) {
      map['codUsuTimber'] = codUsuTimber;
    }
    if (registroAtividade_id != null) {
      map['registroAtividade_id'] = forView
          ? plRegistroAtividade == null
              ? registroAtividade_id
              : plRegistroAtividade!.tabela
          : registroAtividade_id;
    } else if (registroAtividade_id != null || !forView) {
      map['registroAtividade_id'] = null;
    }
    if (lastUpdate != null || !forView) {
      map['lastUpdate'] = lastUpdate;
    }
    if (uniqueKey != null || !forView) {
      map['uniqueKey'] = uniqueKey;
    }
    if (codUsu != null || !forView) {
      map['codUsu'] = codUsu;
    }
    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted! ? 1 : 0) : isDeleted;
    }

    return map;
  }

  /// This method returns Json String [ArquivoRegistroAtividade]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [ArquivoRegistroAtividade]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      idServer,
      sync,
      path,
      codUsuTimber,
      registroAtividade_id,
      lastUpdate,
      uniqueKey,
      codUsu,
      isDeleted
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      id,
      idServer,
      sync,
      path,
      codUsuTimber,
      registroAtividade_id,
      lastUpdate,
      uniqueKey,
      codUsu,
      isDeleted
    ];
  }

  static Future<List<ArquivoRegistroAtividade>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR ArquivoRegistroAtividade.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<ArquivoRegistroAtividade>> fromJson(
      String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <ArquivoRegistroAtividade>[];
    try {
      objList = list
          .map((arquivoregistroatividade) => ArquivoRegistroAtividade.fromMap(
              arquivoregistroatividade as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR ArquivoRegistroAtividade.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<ArquivoRegistroAtividade>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<ArquivoRegistroAtividade> objList = <ArquivoRegistroAtividade>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = ArquivoRegistroAtividade.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plRegistroAtividade'))) {
          obj.plRegistroAtividade = obj.plRegistroAtividade ??
              await obj.getRegistroAtividade(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns ArquivoRegistroAtividade by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [ArquivoRegistroAtividade] if exist, otherwise returns null
  Future<ArquivoRegistroAtividade?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    ArquivoRegistroAtividade? obj;
    final data = await _mnArquivoRegistroAtividade.getById([id]);
    if (data.length != 0) {
      obj = ArquivoRegistroAtividade.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plRegistroAtividade'))) {
          obj.plRegistroAtividade = obj.plRegistroAtividade ??
              await obj.getRegistroAtividade(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (ArquivoRegistroAtividade) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnArquivoRegistroAtividade.insert(this, ignoreBatch);
    } else {
      await _mnArquivoRegistroAtividade.update(this);
    }

    return id;
  }

  /// Saves the (ArquivoRegistroAtividade) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnArquivoRegistroAtividade.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnArquivoRegistroAtividade.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs ArquivoRegistroAtividade. Returns a new Primary Key value of ArquivoRegistroAtividade

  /// <returns>Returns a new Primary Key value of ArquivoRegistroAtividade
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    id = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<ArquivoRegistroAtividade> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<ArquivoRegistroAtividade> arquivoregistroatividades,
      {bool? exclusive,
      bool? noResult,
      bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await AppDatabase().batchStart();
    for (final obj in arquivoregistroatividades) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await AppDatabase().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < arquivoregistroatividades.length; i++) {
        if (arquivoregistroatividades[i].id == null) {
          arquivoregistroatividades[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnArquivoRegistroAtividade.rawInsert(
          'INSERT OR REPLACE INTO ArquivoRegistroAtividade (id, idServer, sync, path, codUsuTimber, registroAtividade_id, lastUpdate, uniqueKey, codUsu,isDeleted)  VALUES (?,?,?,?,?,?,?,?,?,?)',
          [
            id,
            idServer,
            sync,
            path,
            codUsuTimber,
            registroAtividade_id,
            lastUpdate,
            uniqueKey,
            codUsu,
            isDeleted
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'ArquivoRegistroAtividade id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'ArquivoRegistroAtividade id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'ArquivoRegistroAtividade Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<ArquivoRegistroAtividade>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(
      List<ArquivoRegistroAtividade> arquivoregistroatividades,
      {bool? exclusive,
      bool? noResult,
      bool? continueOnError}) async {
    final results = await _mnArquivoRegistroAtividade.rawInsertAll(
        'INSERT OR REPLACE INTO ArquivoRegistroAtividade (id, idServer, sync, path, codUsuTimber, registroAtividade_id, lastUpdate, uniqueKey, codUsu,isDeleted)  VALUES (?,?,?,?,?,?,?,?,?,?)',
        arquivoregistroatividades,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes ArquivoRegistroAtividade

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete ArquivoRegistroAtividade invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete || isDeleted!) {
      return _mnArquivoRegistroAtividade
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnArquivoRegistroAtividade.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  /// Recover ArquivoRegistroAtividade

  /// <returns>BoolResult res.success=Recovered, not res.success=Can not recovered
  @override
  Future<BoolResult> recover([bool recoverChilds = true]) async {
    debugPrint('SQFENTITIY: recover ArquivoRegistroAtividade invoked (id=$id)');
    {
      return _mnArquivoRegistroAtividade.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 0});
    }
  }

  @override
  ArquivoRegistroAtividadeFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return ArquivoRegistroAtividadeFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  ArquivoRegistroAtividadeFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return ArquivoRegistroAtividadeFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    idServer = idServer ?? -1;
    sync = sync ?? true;
    registroAtividade_id = registroAtividade_id ?? 0;
    codUsu = codUsu ?? -2;
    isDeleted = isDeleted ?? false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion arquivoregistroatividade

// region ArquivoRegistroAtividadeField
class ArquivoRegistroAtividadeField extends FilterBase {
  ArquivoRegistroAtividadeField(
      ArquivoRegistroAtividadeFilterBuilder arquivoregistroatividadeFB)
      : super(arquivoregistroatividadeFB);

  @override
  ArquivoRegistroAtividadeFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as ArquivoRegistroAtividadeFilterBuilder;
  }

  @override
  ArquivoRegistroAtividadeFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as ArquivoRegistroAtividadeFilterBuilder;
  }

  @override
  ArquivoRegistroAtividadeFilterBuilder isNull() {
    return super.isNull() as ArquivoRegistroAtividadeFilterBuilder;
  }

  @override
  ArquivoRegistroAtividadeFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as ArquivoRegistroAtividadeFilterBuilder;
  }

  @override
  ArquivoRegistroAtividadeFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as ArquivoRegistroAtividadeFilterBuilder;
  }

  @override
  ArquivoRegistroAtividadeFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as ArquivoRegistroAtividadeFilterBuilder;
  }

  @override
  ArquivoRegistroAtividadeFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast)
        as ArquivoRegistroAtividadeFilterBuilder;
  }

  @override
  ArquivoRegistroAtividadeFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as ArquivoRegistroAtividadeFilterBuilder;
  }

  @override
  ArquivoRegistroAtividadeFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as ArquivoRegistroAtividadeFilterBuilder;
  }

  @override
  ArquivoRegistroAtividadeFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue)
        as ArquivoRegistroAtividadeFilterBuilder;
  }

  @override
  ArquivoRegistroAtividadeFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue)
        as ArquivoRegistroAtividadeFilterBuilder;
  }

  @override
  ArquivoRegistroAtividadeFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as ArquivoRegistroAtividadeFilterBuilder;
  }

  @override
  ArquivoRegistroAtividadeField get not {
    return super.not as ArquivoRegistroAtividadeField;
  }
}
// endregion ArquivoRegistroAtividadeField

// region ArquivoRegistroAtividadeFilterBuilder
class ArquivoRegistroAtividadeFilterBuilder extends ConjunctionBase {
  ArquivoRegistroAtividadeFilterBuilder(
      ArquivoRegistroAtividade obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnArquivoRegistroAtividade = obj._mnArquivoRegistroAtividade;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  ArquivoRegistroAtividadeManager? _mnArquivoRegistroAtividade;

  /// put the sql keyword 'AND'
  @override
  ArquivoRegistroAtividadeFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  ArquivoRegistroAtividadeFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  ArquivoRegistroAtividadeFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  ArquivoRegistroAtividadeFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  ArquivoRegistroAtividadeFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  ArquivoRegistroAtividadeFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  ArquivoRegistroAtividadeFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  ArquivoRegistroAtividadeFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  ArquivoRegistroAtividadeFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  ArquivoRegistroAtividadeFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  ArquivoRegistroAtividadeFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  ArquivoRegistroAtividadeField _setField(
      ArquivoRegistroAtividadeField? field, String colName, DbType dbtype) {
    return ArquivoRegistroAtividadeField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  ArquivoRegistroAtividadeField? _id;
  ArquivoRegistroAtividadeField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  ArquivoRegistroAtividadeField? _idServer;
  ArquivoRegistroAtividadeField get idServer {
    return _idServer = _setField(_idServer, 'idServer', DbType.integer);
  }

  ArquivoRegistroAtividadeField? _sync;
  ArquivoRegistroAtividadeField get sync {
    return _sync = _setField(_sync, 'sync', DbType.bool);
  }

  ArquivoRegistroAtividadeField? _path;
  ArquivoRegistroAtividadeField get path {
    return _path = _setField(_path, 'path', DbType.text);
  }

  ArquivoRegistroAtividadeField? _codUsuTimber;
  ArquivoRegistroAtividadeField get codUsuTimber {
    return _codUsuTimber =
        _setField(_codUsuTimber, 'codUsuTimber', DbType.integer);
  }

  ArquivoRegistroAtividadeField? _registroAtividade_id;
  ArquivoRegistroAtividadeField get registroAtividade_id {
    return _registroAtividade_id = _setField(
        _registroAtividade_id, 'registroAtividade_id', DbType.integer);
  }

  ArquivoRegistroAtividadeField? _lastUpdate;
  ArquivoRegistroAtividadeField get lastUpdate {
    return _lastUpdate = _setField(_lastUpdate, 'lastUpdate', DbType.integer);
  }

  ArquivoRegistroAtividadeField? _uniqueKey;
  ArquivoRegistroAtividadeField get uniqueKey {
    return _uniqueKey = _setField(_uniqueKey, 'uniqueKey', DbType.integer);
  }

  ArquivoRegistroAtividadeField? _codUsu;
  ArquivoRegistroAtividadeField get codUsu {
    return _codUsu = _setField(_codUsu, 'codUsu', DbType.integer);
  }

  ArquivoRegistroAtividadeField? _isDeleted;
  ArquivoRegistroAtividadeField get isDeleted {
    return _isDeleted = _setField(_isDeleted, 'isDeleted', DbType.bool);
  }

  /// Deletes List<ArquivoRegistroAtividade> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnArquivoRegistroAtividade!
          .updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnArquivoRegistroAtividade!.delete(qparams);
    }
    return r;
  }

  /// Recover List<ArquivoRegistroAtividade> bulk by query
  @override
  Future<BoolResult> recover() async {
    buildParameters(getIsDeleted: true);
    debugPrint('SQFENTITIY: recover ArquivoRegistroAtividade bulk invoked');
    return _mnArquivoRegistroAtividade!.updateBatch(qparams, {'isDeleted': 0});
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from ArquivoRegistroAtividade ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnArquivoRegistroAtividade!.updateBatch(qparams, values);
  }

  /// This method always returns [ArquivoRegistroAtividade] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> ArquivoRegistroAtividade?
  @override
  Future<ArquivoRegistroAtividade?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnArquivoRegistroAtividade!.toList(qparams);
    final data = await objFuture;
    ArquivoRegistroAtividade? obj;
    if (data.isNotEmpty) {
      obj = ArquivoRegistroAtividade.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plRegistroAtividade'))) {
          obj.plRegistroAtividade = obj.plRegistroAtividade ??
              await obj.getRegistroAtividade(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [ArquivoRegistroAtividade]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> ArquivoRegistroAtividade?
  @override
  Future<ArquivoRegistroAtividade> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        ArquivoRegistroAtividade();
  }

  /// This method returns int. [ArquivoRegistroAtividade]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? arquivoregistroatividadeCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final arquivoregistroatividadesFuture =
        await _mnArquivoRegistroAtividade!.toList(qparams);
    final int count = arquivoregistroatividadesFuture[0]['CNT'] as int;
    if (arquivoregistroatividadeCount != null) {
      arquivoregistroatividadeCount(count);
    }
    return count;
  }

  /// This method returns List<ArquivoRegistroAtividade> [ArquivoRegistroAtividade]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<ArquivoRegistroAtividade>
  @override
  Future<List<ArquivoRegistroAtividade>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<ArquivoRegistroAtividade> arquivoregistroatividadesData =
        await ArquivoRegistroAtividade.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return arquivoregistroatividadesData;
  }

  /// This method returns Json String [ArquivoRegistroAtividade]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [ArquivoRegistroAtividade]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [ArquivoRegistroAtividade]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnArquivoRegistroAtividade!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [ArquivoRegistroAtividade]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `id` FROM ArquivoRegistroAtividade WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnArquivoRegistroAtividade!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [ArquivoRegistroAtividade]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnArquivoRegistroAtividade!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await ArquivoRegistroAtividade.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnArquivoRegistroAtividade!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion ArquivoRegistroAtividadeFilterBuilder

// region ArquivoRegistroAtividadeFields
class ArquivoRegistroAtividadeFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fIdServer;
  static TableField get idServer {
    return _fIdServer = _fIdServer ??
        SqlSyntax.setField(_fIdServer, 'idServer', DbType.integer);
  }

  static TableField? _fSync;
  static TableField get sync {
    return _fSync = _fSync ?? SqlSyntax.setField(_fSync, 'sync', DbType.bool);
  }

  static TableField? _fPath;
  static TableField get path {
    return _fPath = _fPath ?? SqlSyntax.setField(_fPath, 'path', DbType.text);
  }

  static TableField? _fCodUsuTimber;
  static TableField get codUsuTimber {
    return _fCodUsuTimber = _fCodUsuTimber ??
        SqlSyntax.setField(_fCodUsuTimber, 'codUsuTimber', DbType.integer);
  }

  static TableField? _fRegistroAtividade_id;
  static TableField get registroAtividade_id {
    return _fRegistroAtividade_id = _fRegistroAtividade_id ??
        SqlSyntax.setField(
            _fRegistroAtividade_id, 'registroAtividade_id', DbType.integer);
  }

  static TableField? _fLastUpdate;
  static TableField get lastUpdate {
    return _fLastUpdate = _fLastUpdate ??
        SqlSyntax.setField(_fLastUpdate, 'lastUpdate', DbType.integer);
  }

  static TableField? _fUniqueKey;
  static TableField get uniqueKey {
    return _fUniqueKey = _fUniqueKey ??
        SqlSyntax.setField(_fUniqueKey, 'uniqueKey', DbType.integer);
  }

  static TableField? _fCodUsu;
  static TableField get codUsu {
    return _fCodUsu =
        _fCodUsu ?? SqlSyntax.setField(_fCodUsu, 'codUsu', DbType.integer);
  }

  static TableField? _fIsDeleted;
  static TableField get isDeleted {
    return _fIsDeleted = _fIsDeleted ??
        SqlSyntax.setField(_fIsDeleted, 'isDeleted', DbType.integer);
  }
}
// endregion ArquivoRegistroAtividadeFields

//region ArquivoRegistroAtividadeManager
class ArquivoRegistroAtividadeManager extends SqfEntityProvider {
  ArquivoRegistroAtividadeManager()
      : super(AppDatabase(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'ArquivoRegistroAtividade';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion ArquivoRegistroAtividadeManager
// region FeedbackUsuario
class FeedbackUsuario extends TableBase {
  FeedbackUsuario(
      {this.id,
      this.idServer,
      this.sync,
      this.avaliacao,
      this.texto,
      this.package,
      this.codUsuTimber,
      this.tipoFeedback,
      this.lastUpdate,
      this.uniqueKey,
      this.codUsu,
      this.isDeleted}) {
    _setDefaultValues();
    softDeleteActivated = true;
  }
  FeedbackUsuario.withFields(
      this.idServer,
      this.sync,
      this.avaliacao,
      this.texto,
      this.package,
      this.codUsuTimber,
      this.tipoFeedback,
      this.lastUpdate,
      this.uniqueKey,
      this.codUsu,
      this.isDeleted) {
    _setDefaultValues();
  }
  FeedbackUsuario.withId(
      this.id,
      this.idServer,
      this.sync,
      this.avaliacao,
      this.texto,
      this.package,
      this.codUsuTimber,
      this.tipoFeedback,
      this.lastUpdate,
      this.uniqueKey,
      this.codUsu,
      this.isDeleted) {
    _setDefaultValues();
  }
  // fromMap v2.0
  FeedbackUsuario.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['idServer'] != null) {
      idServer = int.tryParse(o['idServer'].toString());
    }
    if (o['sync'] != null) {
      sync = o['sync'].toString() == '1' || o['sync'].toString() == 'true';
    }
    if (o['avaliacao'] != null) {
      avaliacao = int.tryParse(o['avaliacao'].toString());
    }
    if (o['texto'] != null) {
      texto = o['texto'].toString();
    }
    if (o['package'] != null) {
      package = o['package'].toString();
    }
    if (o['codUsuTimber'] != null) {
      codUsuTimber = int.tryParse(o['codUsuTimber'].toString());
    }
    if (o['tipoFeedback'] != null) {
      tipoFeedback = int.tryParse(o['tipoFeedback'].toString());
    }
    if (o['lastUpdate'] != null) {
      lastUpdate = int.tryParse(o['lastUpdate'].toString());
    }
    if (o['uniqueKey'] != null) {
      uniqueKey = int.tryParse(o['uniqueKey'].toString());
    }
    if (o['codUsu'] != null) {
      codUsu = int.tryParse(o['codUsu'].toString());
    }
    isDeleted = o['isDeleted'] != null
        ? o['isDeleted'] == 1 || o['isDeleted'] == true
        : null;
  }
  // FIELDS (FeedbackUsuario)
  int? id;
  int? idServer;
  bool? sync;
  int? avaliacao;
  String? texto;
  String? package;
  int? codUsuTimber;
  int? tipoFeedback;
  int? lastUpdate;
  int? uniqueKey;
  int? codUsu;
  bool? isDeleted;

  // end FIELDS (FeedbackUsuario)

// COLLECTIONS & VIRTUALS (FeedbackUsuario)
  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plArquivoFeedbacks', 'plField2'..]) or so on..
  List<ArquivoFeedback>? plArquivoFeedbacks;

  /// get ArquivoFeedback(s) filtered by id=feedbackUsuario_id
  ArquivoFeedbackFilterBuilder? getArquivoFeedbacks(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    if (id == null) {
      return null;
    }
    return ArquivoFeedback()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .feedbackUsuario_id
        .equals(id)
        .and;
  }

// END COLLECTIONS & VIRTUALS (FeedbackUsuario)

  static const bool _softDeleteActivated = true;
  FeedbackUsuarioManager? __mnFeedbackUsuario;

  FeedbackUsuarioManager get _mnFeedbackUsuario {
    return __mnFeedbackUsuario =
        __mnFeedbackUsuario ?? FeedbackUsuarioManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (idServer != null || !forView) {
      map['idServer'] = idServer;
    }
    if (sync != null) {
      map['sync'] = forQuery ? (sync! ? 1 : 0) : sync;
    } else if (sync != null || !forView) {
      map['sync'] = null;
    }
    if (avaliacao != null || !forView) {
      map['avaliacao'] = avaliacao;
    }
    if (texto != null || !forView) {
      map['texto'] = texto;
    }
    if (package != null || !forView) {
      map['package'] = package;
    }
    if (codUsuTimber != null || !forView) {
      map['codUsuTimber'] = codUsuTimber;
    }
    if (tipoFeedback != null || !forView) {
      map['tipoFeedback'] = tipoFeedback;
    }
    if (lastUpdate != null || !forView) {
      map['lastUpdate'] = lastUpdate;
    }
    if (uniqueKey != null || !forView) {
      map['uniqueKey'] = uniqueKey;
    }
    if (codUsu != null || !forView) {
      map['codUsu'] = codUsu;
    }
    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted! ? 1 : 0) : isDeleted;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (idServer != null || !forView) {
      map['idServer'] = idServer;
    }
    if (sync != null) {
      map['sync'] = forQuery ? (sync! ? 1 : 0) : sync;
    } else if (sync != null || !forView) {
      map['sync'] = null;
    }
    if (avaliacao != null || !forView) {
      map['avaliacao'] = avaliacao;
    }
    if (texto != null || !forView) {
      map['texto'] = texto;
    }
    if (package != null || !forView) {
      map['package'] = package;
    }
    if (codUsuTimber != null || !forView) {
      map['codUsuTimber'] = codUsuTimber;
    }
    if (tipoFeedback != null || !forView) {
      map['tipoFeedback'] = tipoFeedback;
    }
    if (lastUpdate != null || !forView) {
      map['lastUpdate'] = lastUpdate;
    }
    if (uniqueKey != null || !forView) {
      map['uniqueKey'] = uniqueKey;
    }
    if (codUsu != null || !forView) {
      map['codUsu'] = codUsu;
    }
    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted! ? 1 : 0) : isDeleted;
    }

// COLLECTIONS (FeedbackUsuario)
    if (!forQuery) {
      map['ArquivoFeedbacks'] = await getArquivoFeedbacks()!.toMapList();
    }
// END COLLECTIONS (FeedbackUsuario)

    return map;
  }

  /// This method returns Json String [FeedbackUsuario]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [FeedbackUsuario]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      idServer,
      sync,
      avaliacao,
      texto,
      package,
      codUsuTimber,
      tipoFeedback,
      lastUpdate,
      uniqueKey,
      codUsu,
      isDeleted
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      id,
      idServer,
      sync,
      avaliacao,
      texto,
      package,
      codUsuTimber,
      tipoFeedback,
      lastUpdate,
      uniqueKey,
      codUsu,
      isDeleted
    ];
  }

  static Future<List<FeedbackUsuario>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR FeedbackUsuario.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<FeedbackUsuario>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <FeedbackUsuario>[];
    try {
      objList = list
          .map((feedbackusuario) =>
              FeedbackUsuario.fromMap(feedbackusuario as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR FeedbackUsuario.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<FeedbackUsuario>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<FeedbackUsuario> objList = <FeedbackUsuario>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = FeedbackUsuario.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('FeedbackUsuario.plArquivoFeedbacks') && */ (preloadFields ==
                null ||
            preloadFields.contains('plArquivoFeedbacks'))) {
          /*_loadedfields!.add('FeedbackUsuario.plArquivoFeedbacks'); */ obj
                  .plArquivoFeedbacks =
              obj.plArquivoFeedbacks ??
                  await obj.getArquivoFeedbacks()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      objList.add(obj);
    }
    return objList;
  }

  /// returns FeedbackUsuario by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [FeedbackUsuario] if exist, otherwise returns null
  Future<FeedbackUsuario?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    FeedbackUsuario? obj;
    final data = await _mnFeedbackUsuario.getById([id]);
    if (data.length != 0) {
      obj = FeedbackUsuario.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('FeedbackUsuario.plArquivoFeedbacks') && */ (preloadFields ==
                null ||
            preloadFields.contains('plArquivoFeedbacks'))) {
          /*_loadedfields!.add('FeedbackUsuario.plArquivoFeedbacks'); */ obj
                  .plArquivoFeedbacks =
              obj.plArquivoFeedbacks ??
                  await obj.getArquivoFeedbacks()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (FeedbackUsuario) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnFeedbackUsuario.insert(this, ignoreBatch);
    } else {
      await _mnFeedbackUsuario.update(this);
    }

    return id;
  }

  /// Saves the (FeedbackUsuario) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnFeedbackUsuario.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnFeedbackUsuario.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs FeedbackUsuario. Returns a new Primary Key value of FeedbackUsuario

  /// <returns>Returns a new Primary Key value of FeedbackUsuario
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    id = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<FeedbackUsuario> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<FeedbackUsuario> feedbackusuarios,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await AppDatabase().batchStart();
    for (final obj in feedbackusuarios) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await AppDatabase().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < feedbackusuarios.length; i++) {
        if (feedbackusuarios[i].id == null) {
          feedbackusuarios[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnFeedbackUsuario.rawInsert(
          'INSERT OR REPLACE INTO FeedbackUsuario (id, idServer, sync, avaliacao, texto, package, codUsuTimber, tipoFeedback, lastUpdate, uniqueKey, codUsu,isDeleted)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            id,
            idServer,
            sync,
            avaliacao,
            texto,
            package,
            codUsuTimber,
            tipoFeedback,
            lastUpdate,
            uniqueKey,
            codUsu,
            isDeleted
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'FeedbackUsuario id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'FeedbackUsuario id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'FeedbackUsuario Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<FeedbackUsuario>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<FeedbackUsuario> feedbackusuarios,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnFeedbackUsuario.rawInsertAll(
        'INSERT OR REPLACE INTO FeedbackUsuario (id, idServer, sync, avaliacao, texto, package, codUsuTimber, tipoFeedback, lastUpdate, uniqueKey, codUsu,isDeleted)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?)',
        feedbackusuarios,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes FeedbackUsuario

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete FeedbackUsuario invoked (id=$id)');
    var result = BoolResult(success: false);
    {
      result = await ArquivoFeedback()
          .select()
          .feedbackUsuario_id
          .equals(id)
          .and
          .delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    if (!_softDeleteActivated || hardDelete || isDeleted!) {
      return _mnFeedbackUsuario
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnFeedbackUsuario.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  /// Recover FeedbackUsuario

  /// <returns>BoolResult res.success=Recovered, not res.success=Can not recovered
  @override
  Future<BoolResult> recover([bool recoverChilds = true]) async {
    debugPrint('SQFENTITIY: recover FeedbackUsuario invoked (id=$id)');
    var result = BoolResult(success: false);
    if (recoverChilds) {
      result = await ArquivoFeedback()
          .select(getIsDeleted: true)
          .isDeleted
          .equals(true)
          .and
          .feedbackUsuario_id
          .equals(id)
          .and
          .update({'isDeleted': 0});
    }
    if (!result.success && recoverChilds) {
      return result;
    }
    {
      return _mnFeedbackUsuario.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 0});
    }
  }

  @override
  FeedbackUsuarioFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return FeedbackUsuarioFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  FeedbackUsuarioFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return FeedbackUsuarioFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    idServer = idServer ?? -1;
    sync = sync ?? true;
    codUsu = codUsu ?? -2;
    isDeleted = isDeleted ?? false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion feedbackusuario

// region FeedbackUsuarioField
class FeedbackUsuarioField extends FilterBase {
  FeedbackUsuarioField(FeedbackUsuarioFilterBuilder feedbackusuarioFB)
      : super(feedbackusuarioFB);

  @override
  FeedbackUsuarioFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as FeedbackUsuarioFilterBuilder;
  }

  @override
  FeedbackUsuarioFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as FeedbackUsuarioFilterBuilder;
  }

  @override
  FeedbackUsuarioFilterBuilder isNull() {
    return super.isNull() as FeedbackUsuarioFilterBuilder;
  }

  @override
  FeedbackUsuarioFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as FeedbackUsuarioFilterBuilder;
  }

  @override
  FeedbackUsuarioFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as FeedbackUsuarioFilterBuilder;
  }

  @override
  FeedbackUsuarioFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as FeedbackUsuarioFilterBuilder;
  }

  @override
  FeedbackUsuarioFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as FeedbackUsuarioFilterBuilder;
  }

  @override
  FeedbackUsuarioFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as FeedbackUsuarioFilterBuilder;
  }

  @override
  FeedbackUsuarioFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as FeedbackUsuarioFilterBuilder;
  }

  @override
  FeedbackUsuarioFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as FeedbackUsuarioFilterBuilder;
  }

  @override
  FeedbackUsuarioFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as FeedbackUsuarioFilterBuilder;
  }

  @override
  FeedbackUsuarioFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as FeedbackUsuarioFilterBuilder;
  }

  @override
  FeedbackUsuarioField get not {
    return super.not as FeedbackUsuarioField;
  }
}
// endregion FeedbackUsuarioField

// region FeedbackUsuarioFilterBuilder
class FeedbackUsuarioFilterBuilder extends ConjunctionBase {
  FeedbackUsuarioFilterBuilder(FeedbackUsuario obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnFeedbackUsuario = obj._mnFeedbackUsuario;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  FeedbackUsuarioManager? _mnFeedbackUsuario;

  /// put the sql keyword 'AND'
  @override
  FeedbackUsuarioFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  FeedbackUsuarioFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  FeedbackUsuarioFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  FeedbackUsuarioFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  FeedbackUsuarioFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  FeedbackUsuarioFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  FeedbackUsuarioFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  FeedbackUsuarioFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  FeedbackUsuarioFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  FeedbackUsuarioFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  FeedbackUsuarioFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  FeedbackUsuarioField _setField(
      FeedbackUsuarioField? field, String colName, DbType dbtype) {
    return FeedbackUsuarioField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  FeedbackUsuarioField? _id;
  FeedbackUsuarioField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  FeedbackUsuarioField? _idServer;
  FeedbackUsuarioField get idServer {
    return _idServer = _setField(_idServer, 'idServer', DbType.integer);
  }

  FeedbackUsuarioField? _sync;
  FeedbackUsuarioField get sync {
    return _sync = _setField(_sync, 'sync', DbType.bool);
  }

  FeedbackUsuarioField? _avaliacao;
  FeedbackUsuarioField get avaliacao {
    return _avaliacao = _setField(_avaliacao, 'avaliacao', DbType.integer);
  }

  FeedbackUsuarioField? _texto;
  FeedbackUsuarioField get texto {
    return _texto = _setField(_texto, 'texto', DbType.text);
  }

  FeedbackUsuarioField? _package;
  FeedbackUsuarioField get package {
    return _package = _setField(_package, 'package', DbType.text);
  }

  FeedbackUsuarioField? _codUsuTimber;
  FeedbackUsuarioField get codUsuTimber {
    return _codUsuTimber =
        _setField(_codUsuTimber, 'codUsuTimber', DbType.integer);
  }

  FeedbackUsuarioField? _tipoFeedback;
  FeedbackUsuarioField get tipoFeedback {
    return _tipoFeedback =
        _setField(_tipoFeedback, 'tipoFeedback', DbType.integer);
  }

  FeedbackUsuarioField? _lastUpdate;
  FeedbackUsuarioField get lastUpdate {
    return _lastUpdate = _setField(_lastUpdate, 'lastUpdate', DbType.integer);
  }

  FeedbackUsuarioField? _uniqueKey;
  FeedbackUsuarioField get uniqueKey {
    return _uniqueKey = _setField(_uniqueKey, 'uniqueKey', DbType.integer);
  }

  FeedbackUsuarioField? _codUsu;
  FeedbackUsuarioField get codUsu {
    return _codUsu = _setField(_codUsu, 'codUsu', DbType.integer);
  }

  FeedbackUsuarioField? _isDeleted;
  FeedbackUsuarioField get isDeleted {
    return _isDeleted = _setField(_isDeleted, 'isDeleted', DbType.bool);
  }

  /// Deletes List<FeedbackUsuario> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);
    // Delete sub records where in (ArquivoFeedback) according to DeleteRule.CASCADE
    final idListArquivoFeedbackBYfeedbackUsuario_id =
        toListPrimaryKeySQL(false);
    final resArquivoFeedbackBYfeedbackUsuario_id = await ArquivoFeedback()
        .select()
        .where(
            'feedbackUsuario_id IN (${idListArquivoFeedbackBYfeedbackUsuario_id['sql']})',
            parameterValue: idListArquivoFeedbackBYfeedbackUsuario_id['args'])
        .delete(hardDelete);
    if (!resArquivoFeedbackBYfeedbackUsuario_id.success) {
      return resArquivoFeedbackBYfeedbackUsuario_id;
    }

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnFeedbackUsuario!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnFeedbackUsuario!.delete(qparams);
    }
    return r;
  }

  /// Recover List<FeedbackUsuario> bulk by query
  @override
  Future<BoolResult> recover() async {
    buildParameters(getIsDeleted: true);
    debugPrint('SQFENTITIY: recover FeedbackUsuario bulk invoked');
    // Recover sub records where in (ArquivoFeedback) according to DeleteRule.CASCADE
    final idListArquivoFeedbackBYfeedbackUsuario_id =
        toListPrimaryKeySQL(false);
    final resArquivoFeedbackBYfeedbackUsuario_id = await ArquivoFeedback()
        .select()
        .where(
            'feedbackUsuario_id IN (${idListArquivoFeedbackBYfeedbackUsuario_id['sql']})',
            parameterValue: idListArquivoFeedbackBYfeedbackUsuario_id['args'])
        .update({'isDeleted': 0});
    if (!resArquivoFeedbackBYfeedbackUsuario_id.success) {
      return resArquivoFeedbackBYfeedbackUsuario_id;
    }
    return _mnFeedbackUsuario!.updateBatch(qparams, {'isDeleted': 0});
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from FeedbackUsuario ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnFeedbackUsuario!.updateBatch(qparams, values);
  }

  /// This method always returns [FeedbackUsuario] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> FeedbackUsuario?
  @override
  Future<FeedbackUsuario?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnFeedbackUsuario!.toList(qparams);
    final data = await objFuture;
    FeedbackUsuario? obj;
    if (data.isNotEmpty) {
      obj = FeedbackUsuario.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedfields!.contains('FeedbackUsuario.plArquivoFeedbacks') && */ (preloadFields ==
                null ||
            preloadFields.contains('plArquivoFeedbacks'))) {
          /*_loadedfields!.add('FeedbackUsuario.plArquivoFeedbacks'); */ obj
                  .plArquivoFeedbacks =
              obj.plArquivoFeedbacks ??
                  await obj.getArquivoFeedbacks()!.toList(
                      preload: preload,
                      preloadFields: preloadFields,
                      loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [FeedbackUsuario]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> FeedbackUsuario?
  @override
  Future<FeedbackUsuario> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        FeedbackUsuario();
  }

  /// This method returns int. [FeedbackUsuario]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? feedbackusuarioCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final feedbackusuariosFuture = await _mnFeedbackUsuario!.toList(qparams);
    final int count = feedbackusuariosFuture[0]['CNT'] as int;
    if (feedbackusuarioCount != null) {
      feedbackusuarioCount(count);
    }
    return count;
  }

  /// This method returns List<FeedbackUsuario> [FeedbackUsuario]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<FeedbackUsuario>
  @override
  Future<List<FeedbackUsuario>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<FeedbackUsuario> feedbackusuariosData =
        await FeedbackUsuario.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return feedbackusuariosData;
  }

  /// This method returns Json String [FeedbackUsuario]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [FeedbackUsuario]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [FeedbackUsuario]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnFeedbackUsuario!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [FeedbackUsuario]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `id` FROM FeedbackUsuario WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnFeedbackUsuario!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [FeedbackUsuario]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnFeedbackUsuario!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await FeedbackUsuario.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnFeedbackUsuario!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion FeedbackUsuarioFilterBuilder

// region FeedbackUsuarioFields
class FeedbackUsuarioFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fIdServer;
  static TableField get idServer {
    return _fIdServer = _fIdServer ??
        SqlSyntax.setField(_fIdServer, 'idServer', DbType.integer);
  }

  static TableField? _fSync;
  static TableField get sync {
    return _fSync = _fSync ?? SqlSyntax.setField(_fSync, 'sync', DbType.bool);
  }

  static TableField? _fAvaliacao;
  static TableField get avaliacao {
    return _fAvaliacao = _fAvaliacao ??
        SqlSyntax.setField(_fAvaliacao, 'avaliacao', DbType.integer);
  }

  static TableField? _fTexto;
  static TableField get texto {
    return _fTexto =
        _fTexto ?? SqlSyntax.setField(_fTexto, 'texto', DbType.text);
  }

  static TableField? _fPackage;
  static TableField get package {
    return _fPackage =
        _fPackage ?? SqlSyntax.setField(_fPackage, 'package', DbType.text);
  }

  static TableField? _fCodUsuTimber;
  static TableField get codUsuTimber {
    return _fCodUsuTimber = _fCodUsuTimber ??
        SqlSyntax.setField(_fCodUsuTimber, 'codUsuTimber', DbType.integer);
  }

  static TableField? _fTipoFeedback;
  static TableField get tipoFeedback {
    return _fTipoFeedback = _fTipoFeedback ??
        SqlSyntax.setField(_fTipoFeedback, 'tipoFeedback', DbType.integer);
  }

  static TableField? _fLastUpdate;
  static TableField get lastUpdate {
    return _fLastUpdate = _fLastUpdate ??
        SqlSyntax.setField(_fLastUpdate, 'lastUpdate', DbType.integer);
  }

  static TableField? _fUniqueKey;
  static TableField get uniqueKey {
    return _fUniqueKey = _fUniqueKey ??
        SqlSyntax.setField(_fUniqueKey, 'uniqueKey', DbType.integer);
  }

  static TableField? _fCodUsu;
  static TableField get codUsu {
    return _fCodUsu =
        _fCodUsu ?? SqlSyntax.setField(_fCodUsu, 'codUsu', DbType.integer);
  }

  static TableField? _fIsDeleted;
  static TableField get isDeleted {
    return _fIsDeleted = _fIsDeleted ??
        SqlSyntax.setField(_fIsDeleted, 'isDeleted', DbType.integer);
  }
}
// endregion FeedbackUsuarioFields

//region FeedbackUsuarioManager
class FeedbackUsuarioManager extends SqfEntityProvider {
  FeedbackUsuarioManager()
      : super(AppDatabase(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'FeedbackUsuario';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion FeedbackUsuarioManager
// region ArquivoFeedback
class ArquivoFeedback extends TableBase {
  ArquivoFeedback(
      {this.id,
      this.idServer,
      this.sync,
      this.url,
      this.path,
      this.codUsuTimber,
      this.feedbackUsuario_id,
      this.lastUpdate,
      this.uniqueKey,
      this.codUsu,
      this.isDeleted}) {
    _setDefaultValues();
    softDeleteActivated = true;
  }
  ArquivoFeedback.withFields(
      this.idServer,
      this.sync,
      this.url,
      this.path,
      this.codUsuTimber,
      this.feedbackUsuario_id,
      this.lastUpdate,
      this.uniqueKey,
      this.codUsu,
      this.isDeleted) {
    _setDefaultValues();
  }
  ArquivoFeedback.withId(
      this.id,
      this.idServer,
      this.sync,
      this.url,
      this.path,
      this.codUsuTimber,
      this.feedbackUsuario_id,
      this.lastUpdate,
      this.uniqueKey,
      this.codUsu,
      this.isDeleted) {
    _setDefaultValues();
  }
  // fromMap v2.0
  ArquivoFeedback.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['idServer'] != null) {
      idServer = int.tryParse(o['idServer'].toString());
    }
    if (o['sync'] != null) {
      sync = o['sync'].toString() == '1' || o['sync'].toString() == 'true';
    }
    if (o['url'] != null) {
      url = o['url'].toString();
    }
    if (o['path'] != null) {
      path = o['path'].toString();
    }
    if (o['codUsuTimber'] != null) {
      codUsuTimber = int.tryParse(o['codUsuTimber'].toString());
    }
    feedbackUsuario_id = int.tryParse(o['feedbackUsuario_id'].toString());

    if (o['lastUpdate'] != null) {
      lastUpdate = int.tryParse(o['lastUpdate'].toString());
    }
    if (o['uniqueKey'] != null) {
      uniqueKey = int.tryParse(o['uniqueKey'].toString());
    }
    if (o['codUsu'] != null) {
      codUsu = int.tryParse(o['codUsu'].toString());
    }
    isDeleted = o['isDeleted'] != null
        ? o['isDeleted'] == 1 || o['isDeleted'] == true
        : null;

    // RELATIONSHIPS FromMAP
    plFeedbackUsuario = o['feedbackUsuario'] != null
        ? FeedbackUsuario.fromMap(o['feedbackUsuario'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP
  }
  // FIELDS (ArquivoFeedback)
  int? id;
  int? idServer;
  bool? sync;
  String? url;
  String? path;
  int? codUsuTimber;
  int? feedbackUsuario_id;
  int? lastUpdate;
  int? uniqueKey;
  int? codUsu;
  bool? isDeleted;

  // end FIELDS (ArquivoFeedback)

// RELATIONSHIPS (ArquivoFeedback)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields!. Ex: toList(preload:true, preloadFields:['plFeedbackUsuario', 'plField2'..]) or so on..
  FeedbackUsuario? plFeedbackUsuario;

  /// get FeedbackUsuario By FeedbackUsuario_id
  Future<FeedbackUsuario?> getFeedbackUsuario(
      {bool loadParents = false, List<String>? loadedFields}) async {
    final _obj = await FeedbackUsuario().getById(feedbackUsuario_id,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (ArquivoFeedback)

  static const bool _softDeleteActivated = true;
  ArquivoFeedbackManager? __mnArquivoFeedback;

  ArquivoFeedbackManager get _mnArquivoFeedback {
    return __mnArquivoFeedback =
        __mnArquivoFeedback ?? ArquivoFeedbackManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (idServer != null || !forView) {
      map['idServer'] = idServer;
    }
    if (sync != null) {
      map['sync'] = forQuery ? (sync! ? 1 : 0) : sync;
    } else if (sync != null || !forView) {
      map['sync'] = null;
    }
    if (url != null || !forView) {
      map['url'] = url;
    }
    if (path != null || !forView) {
      map['path'] = path;
    }
    if (codUsuTimber != null || !forView) {
      map['codUsuTimber'] = codUsuTimber;
    }
    if (feedbackUsuario_id != null) {
      map['feedbackUsuario_id'] = forView
          ? plFeedbackUsuario == null
              ? feedbackUsuario_id
              : plFeedbackUsuario!.texto
          : feedbackUsuario_id;
    } else if (feedbackUsuario_id != null || !forView) {
      map['feedbackUsuario_id'] = null;
    }
    if (lastUpdate != null || !forView) {
      map['lastUpdate'] = lastUpdate;
    }
    if (uniqueKey != null || !forView) {
      map['uniqueKey'] = uniqueKey;
    }
    if (codUsu != null || !forView) {
      map['codUsu'] = codUsu;
    }
    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted! ? 1 : 0) : isDeleted;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (idServer != null || !forView) {
      map['idServer'] = idServer;
    }
    if (sync != null) {
      map['sync'] = forQuery ? (sync! ? 1 : 0) : sync;
    } else if (sync != null || !forView) {
      map['sync'] = null;
    }
    if (url != null || !forView) {
      map['url'] = url;
    }
    if (path != null || !forView) {
      map['path'] = path;
    }
    if (codUsuTimber != null || !forView) {
      map['codUsuTimber'] = codUsuTimber;
    }
    if (feedbackUsuario_id != null) {
      map['feedbackUsuario_id'] = forView
          ? plFeedbackUsuario == null
              ? feedbackUsuario_id
              : plFeedbackUsuario!.texto
          : feedbackUsuario_id;
    } else if (feedbackUsuario_id != null || !forView) {
      map['feedbackUsuario_id'] = null;
    }
    if (lastUpdate != null || !forView) {
      map['lastUpdate'] = lastUpdate;
    }
    if (uniqueKey != null || !forView) {
      map['uniqueKey'] = uniqueKey;
    }
    if (codUsu != null || !forView) {
      map['codUsu'] = codUsu;
    }
    if (isDeleted != null) {
      map['isDeleted'] = forQuery ? (isDeleted! ? 1 : 0) : isDeleted;
    }

    return map;
  }

  /// This method returns Json String [ArquivoFeedback]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [ArquivoFeedback]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      idServer,
      sync,
      url,
      path,
      codUsuTimber,
      feedbackUsuario_id,
      lastUpdate,
      uniqueKey,
      codUsu,
      isDeleted
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      id,
      idServer,
      sync,
      url,
      path,
      codUsuTimber,
      feedbackUsuario_id,
      lastUpdate,
      uniqueKey,
      codUsu,
      isDeleted
    ];
  }

  static Future<List<ArquivoFeedback>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR ArquivoFeedback.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<ArquivoFeedback>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <ArquivoFeedback>[];
    try {
      objList = list
          .map((arquivofeedback) =>
              ArquivoFeedback.fromMap(arquivofeedback as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR ArquivoFeedback.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<ArquivoFeedback>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<ArquivoFeedback> objList = <ArquivoFeedback>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = ArquivoFeedback.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plFeedbackUsuario'))) {
          obj.plFeedbackUsuario = obj.plFeedbackUsuario ??
              await obj.getFeedbackUsuario(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns ArquivoFeedback by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [ArquivoFeedback] if exist, otherwise returns null
  Future<ArquivoFeedback?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    ArquivoFeedback? obj;
    final data = await _mnArquivoFeedback.getById([id]);
    if (data.length != 0) {
      obj = ArquivoFeedback.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plFeedbackUsuario'))) {
          obj.plFeedbackUsuario = obj.plFeedbackUsuario ??
              await obj.getFeedbackUsuario(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (ArquivoFeedback) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnArquivoFeedback.insert(this, ignoreBatch);
    } else {
      await _mnArquivoFeedback.update(this);
    }

    return id;
  }

  /// Saves the (ArquivoFeedback) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnArquivoFeedback.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnArquivoFeedback.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs ArquivoFeedback. Returns a new Primary Key value of ArquivoFeedback

  /// <returns>Returns a new Primary Key value of ArquivoFeedback
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    id = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<ArquivoFeedback> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<ArquivoFeedback> arquivofeedbacks,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await AppDatabase().batchStart();
    for (final obj in arquivofeedbacks) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await AppDatabase().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < arquivofeedbacks.length; i++) {
        if (arquivofeedbacks[i].id == null) {
          arquivofeedbacks[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnArquivoFeedback.rawInsert(
          'INSERT OR REPLACE INTO ArquivoFeedback (id, idServer, sync, url, path, codUsuTimber, feedbackUsuario_id, lastUpdate, uniqueKey, codUsu,isDeleted)  VALUES (?,?,?,?,?,?,?,?,?,?,?)',
          [
            id,
            idServer,
            sync,
            url,
            path,
            codUsuTimber,
            feedbackUsuario_id,
            lastUpdate,
            uniqueKey,
            codUsu,
            isDeleted
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'ArquivoFeedback id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'ArquivoFeedback id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'ArquivoFeedback Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<ArquivoFeedback>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<ArquivoFeedback> arquivofeedbacks,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnArquivoFeedback.rawInsertAll(
        'INSERT OR REPLACE INTO ArquivoFeedback (id, idServer, sync, url, path, codUsuTimber, feedbackUsuario_id, lastUpdate, uniqueKey, codUsu,isDeleted)  VALUES (?,?,?,?,?,?,?,?,?,?,?)',
        arquivofeedbacks,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes ArquivoFeedback

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete ArquivoFeedback invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete || isDeleted!) {
      return _mnArquivoFeedback
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnArquivoFeedback.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  /// Recover ArquivoFeedback

  /// <returns>BoolResult res.success=Recovered, not res.success=Can not recovered
  @override
  Future<BoolResult> recover([bool recoverChilds = true]) async {
    debugPrint('SQFENTITIY: recover ArquivoFeedback invoked (id=$id)');
    {
      return _mnArquivoFeedback.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 0});
    }
  }

  @override
  ArquivoFeedbackFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return ArquivoFeedbackFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  ArquivoFeedbackFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return ArquivoFeedbackFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    idServer = idServer ?? -1;
    sync = sync ?? true;
    feedbackUsuario_id = feedbackUsuario_id ?? 0;
    codUsu = codUsu ?? -2;
    isDeleted = isDeleted ?? false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion arquivofeedback

// region ArquivoFeedbackField
class ArquivoFeedbackField extends FilterBase {
  ArquivoFeedbackField(ArquivoFeedbackFilterBuilder arquivofeedbackFB)
      : super(arquivofeedbackFB);

  @override
  ArquivoFeedbackFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as ArquivoFeedbackFilterBuilder;
  }

  @override
  ArquivoFeedbackFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as ArquivoFeedbackFilterBuilder;
  }

  @override
  ArquivoFeedbackFilterBuilder isNull() {
    return super.isNull() as ArquivoFeedbackFilterBuilder;
  }

  @override
  ArquivoFeedbackFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as ArquivoFeedbackFilterBuilder;
  }

  @override
  ArquivoFeedbackFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as ArquivoFeedbackFilterBuilder;
  }

  @override
  ArquivoFeedbackFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as ArquivoFeedbackFilterBuilder;
  }

  @override
  ArquivoFeedbackFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as ArquivoFeedbackFilterBuilder;
  }

  @override
  ArquivoFeedbackFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as ArquivoFeedbackFilterBuilder;
  }

  @override
  ArquivoFeedbackFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as ArquivoFeedbackFilterBuilder;
  }

  @override
  ArquivoFeedbackFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as ArquivoFeedbackFilterBuilder;
  }

  @override
  ArquivoFeedbackFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as ArquivoFeedbackFilterBuilder;
  }

  @override
  ArquivoFeedbackFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as ArquivoFeedbackFilterBuilder;
  }

  @override
  ArquivoFeedbackField get not {
    return super.not as ArquivoFeedbackField;
  }
}
// endregion ArquivoFeedbackField

// region ArquivoFeedbackFilterBuilder
class ArquivoFeedbackFilterBuilder extends ConjunctionBase {
  ArquivoFeedbackFilterBuilder(ArquivoFeedback obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnArquivoFeedback = obj._mnArquivoFeedback;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  ArquivoFeedbackManager? _mnArquivoFeedback;

  /// put the sql keyword 'AND'
  @override
  ArquivoFeedbackFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  ArquivoFeedbackFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  ArquivoFeedbackFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  ArquivoFeedbackFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  ArquivoFeedbackFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  ArquivoFeedbackFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  ArquivoFeedbackFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  ArquivoFeedbackFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  ArquivoFeedbackFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  ArquivoFeedbackFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  ArquivoFeedbackFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  ArquivoFeedbackField _setField(
      ArquivoFeedbackField? field, String colName, DbType dbtype) {
    return ArquivoFeedbackField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  ArquivoFeedbackField? _id;
  ArquivoFeedbackField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  ArquivoFeedbackField? _idServer;
  ArquivoFeedbackField get idServer {
    return _idServer = _setField(_idServer, 'idServer', DbType.integer);
  }

  ArquivoFeedbackField? _sync;
  ArquivoFeedbackField get sync {
    return _sync = _setField(_sync, 'sync', DbType.bool);
  }

  ArquivoFeedbackField? _url;
  ArquivoFeedbackField get url {
    return _url = _setField(_url, 'url', DbType.text);
  }

  ArquivoFeedbackField? _path;
  ArquivoFeedbackField get path {
    return _path = _setField(_path, 'path', DbType.text);
  }

  ArquivoFeedbackField? _codUsuTimber;
  ArquivoFeedbackField get codUsuTimber {
    return _codUsuTimber =
        _setField(_codUsuTimber, 'codUsuTimber', DbType.integer);
  }

  ArquivoFeedbackField? _feedbackUsuario_id;
  ArquivoFeedbackField get feedbackUsuario_id {
    return _feedbackUsuario_id =
        _setField(_feedbackUsuario_id, 'feedbackUsuario_id', DbType.integer);
  }

  ArquivoFeedbackField? _lastUpdate;
  ArquivoFeedbackField get lastUpdate {
    return _lastUpdate = _setField(_lastUpdate, 'lastUpdate', DbType.integer);
  }

  ArquivoFeedbackField? _uniqueKey;
  ArquivoFeedbackField get uniqueKey {
    return _uniqueKey = _setField(_uniqueKey, 'uniqueKey', DbType.integer);
  }

  ArquivoFeedbackField? _codUsu;
  ArquivoFeedbackField get codUsu {
    return _codUsu = _setField(_codUsu, 'codUsu', DbType.integer);
  }

  ArquivoFeedbackField? _isDeleted;
  ArquivoFeedbackField get isDeleted {
    return _isDeleted = _setField(_isDeleted, 'isDeleted', DbType.bool);
  }

  /// Deletes List<ArquivoFeedback> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnArquivoFeedback!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnArquivoFeedback!.delete(qparams);
    }
    return r;
  }

  /// Recover List<ArquivoFeedback> bulk by query
  @override
  Future<BoolResult> recover() async {
    buildParameters(getIsDeleted: true);
    debugPrint('SQFENTITIY: recover ArquivoFeedback bulk invoked');
    return _mnArquivoFeedback!.updateBatch(qparams, {'isDeleted': 0});
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from ArquivoFeedback ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnArquivoFeedback!.updateBatch(qparams, values);
  }

  /// This method always returns [ArquivoFeedback] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> ArquivoFeedback?
  @override
  Future<ArquivoFeedback?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnArquivoFeedback!.toList(qparams);
    final data = await objFuture;
    ArquivoFeedback? obj;
    if (data.isNotEmpty) {
      obj = ArquivoFeedback.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if ((preloadFields == null ||
            loadParents ||
            preloadFields.contains('plFeedbackUsuario'))) {
          obj.plFeedbackUsuario = obj.plFeedbackUsuario ??
              await obj.getFeedbackUsuario(loadParents: loadParents);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [ArquivoFeedback]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> ArquivoFeedback?
  @override
  Future<ArquivoFeedback> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        ArquivoFeedback();
  }

  /// This method returns int. [ArquivoFeedback]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? arquivofeedbackCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final arquivofeedbacksFuture = await _mnArquivoFeedback!.toList(qparams);
    final int count = arquivofeedbacksFuture[0]['CNT'] as int;
    if (arquivofeedbackCount != null) {
      arquivofeedbackCount(count);
    }
    return count;
  }

  /// This method returns List<ArquivoFeedback> [ArquivoFeedback]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<ArquivoFeedback>
  @override
  Future<List<ArquivoFeedback>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<ArquivoFeedback> arquivofeedbacksData =
        await ArquivoFeedback.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return arquivofeedbacksData;
  }

  /// This method returns Json String [ArquivoFeedback]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [ArquivoFeedback]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [ArquivoFeedback]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnArquivoFeedback!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [ArquivoFeedback]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `id` FROM ArquivoFeedback WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnArquivoFeedback!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [ArquivoFeedback]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnArquivoFeedback!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await ArquivoFeedback.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnArquivoFeedback!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion ArquivoFeedbackFilterBuilder

// region ArquivoFeedbackFields
class ArquivoFeedbackFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fIdServer;
  static TableField get idServer {
    return _fIdServer = _fIdServer ??
        SqlSyntax.setField(_fIdServer, 'idServer', DbType.integer);
  }

  static TableField? _fSync;
  static TableField get sync {
    return _fSync = _fSync ?? SqlSyntax.setField(_fSync, 'sync', DbType.bool);
  }

  static TableField? _fUrl;
  static TableField get url {
    return _fUrl = _fUrl ?? SqlSyntax.setField(_fUrl, 'url', DbType.text);
  }

  static TableField? _fPath;
  static TableField get path {
    return _fPath = _fPath ?? SqlSyntax.setField(_fPath, 'path', DbType.text);
  }

  static TableField? _fCodUsuTimber;
  static TableField get codUsuTimber {
    return _fCodUsuTimber = _fCodUsuTimber ??
        SqlSyntax.setField(_fCodUsuTimber, 'codUsuTimber', DbType.integer);
  }

  static TableField? _fFeedbackUsuario_id;
  static TableField get feedbackUsuario_id {
    return _fFeedbackUsuario_id = _fFeedbackUsuario_id ??
        SqlSyntax.setField(
            _fFeedbackUsuario_id, 'feedbackUsuario_id', DbType.integer);
  }

  static TableField? _fLastUpdate;
  static TableField get lastUpdate {
    return _fLastUpdate = _fLastUpdate ??
        SqlSyntax.setField(_fLastUpdate, 'lastUpdate', DbType.integer);
  }

  static TableField? _fUniqueKey;
  static TableField get uniqueKey {
    return _fUniqueKey = _fUniqueKey ??
        SqlSyntax.setField(_fUniqueKey, 'uniqueKey', DbType.integer);
  }

  static TableField? _fCodUsu;
  static TableField get codUsu {
    return _fCodUsu =
        _fCodUsu ?? SqlSyntax.setField(_fCodUsu, 'codUsu', DbType.integer);
  }

  static TableField? _fIsDeleted;
  static TableField get isDeleted {
    return _fIsDeleted = _fIsDeleted ??
        SqlSyntax.setField(_fIsDeleted, 'isDeleted', DbType.integer);
  }
}
// endregion ArquivoFeedbackFields

//region ArquivoFeedbackManager
class ArquivoFeedbackManager extends SqfEntityProvider {
  ArquivoFeedbackManager()
      : super(AppDatabase(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'ArquivoFeedback';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion ArquivoFeedbackManager
/// Region SEQUENCE IdentitySequence
class IdentitySequence {
  /// Assigns a new value when it is triggered and returns the new value
  /// returns Future<int>
  Future<int> nextVal([VoidCallback Function(int o)? nextval]) async {
    final val = await AppDatabaseSequenceManager()
        .sequence(SequenceIdentitySequence.getInstance, true);
    if (nextval != null) {
      nextval(val);
    }
    return val;
  }

  /// Get the current value
  /// returns Future<int>
  Future<int> currentVal([VoidCallback Function(int o)? currentval]) async {
    final val = await AppDatabaseSequenceManager()
        .sequence(SequenceIdentitySequence.getInstance, false);
    if (currentval != null) {
      currentval(val);
    }
    return val;
  }

  /// Reset sequence to start value
  /// returns start value
  Future<int> reset([VoidCallback Function(int o)? currentval]) async {
    final val = await AppDatabaseSequenceManager()
        .sequence(SequenceIdentitySequence.getInstance, false, reset: true);
    if (currentval != null) {
      currentval(val);
    }
    return val;
  }
}

/// End Region SEQUENCE IdentitySequence

class AppDatabaseSequenceManager extends SqfEntityProvider {
  AppDatabaseSequenceManager() : super(AppDatabase());
}
// END OF ENTITIES
